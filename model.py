import pandas as pd
import numpy as np
import requests as req
import pygame as pg
import matplotlib as mpl
import plotly as plt
import argparse as ap
import sys
from os import getcwd

from requests.models import REDIRECT_STATI

# NOTE: this is serving as a preamble of init classes / importing parameters

SCREENSIZE = (800, 800)
PWD = getcwd()

# common colors
WHITE   = (255,255,255)
RED     = (255,0,0)
BLUE    = (0,0,255)
BLACK   = (0,0,0)
GREEN   = (0,255,0)

# NOTE: handle argparsing
parser = ap.ArgumentParser(description="A script to generate an agent based model simulating paths generated by ants and their pheromone trails")

parser.add_argument("--agents", type=str, help="Max number of concurrent agents in the model")
parser.add_argument("--kernel", type=int, help="Selected turning kernel")
parser.add_argument("--fidelity", type=int, help="Select which fidelity case to model") 
#TODO: this^ may need to be a boolean
parser.add_argument("--max-time", type=int, help="Max simulation time our model will run")
parser.add_argument("--time-step", type=float, help="Time resolution of our model")

args = parser.parse_args()

class TurningKernel():
    # making a class for turning kernels to act as a template we can alter later
    # TODO:look at a continously defined turning kernel
    def __init__(self, one:float = 0.25 , two:float = 0.25 , three:float = 0.25 , four:float = 0.25 )->None:
        self.left = one
        self.forward = two
        self.right = three
        self.backward = four

    def get_tk(self,):
        #TODO: need to figure out if this will randomly select a direction here, or pass the values,
        # if latter then this should not be a class
        # FIX: add code here
        pass

class pheromone(pg.sprite.Sprite):
    def __init__(self, position:tuple[int,int], initVal:float):
        super().__init__()
        # Load the image for the agent
        # TODO: standardize image that comes in / size it
        height = 1
        width = 1
        
        self.image = pg.Surface([width, height])
        self.image.fill(RED)
        self.image.set_colorkey(RED)
        self.rect = self.image.get_rect()
        # Set the initial position of the agent
        self.rect.topleft = position

    def update(self,decrement=False)->None:
        # Boolean to determine if we're decrementing the pheromone trail or if 
        # were reseting it


class Agent():
    # TODO: combine this into one class
    class _Sprite(pg.sprite.Sprite):    
        def __init__(self, image, initial_position:tuple[int,int]=(0, 0)):
            super().__init__()
            # Load the image for the agent
            # TODO: standardize image that comes in / size it
            self.image = pg.image.load(image)  
            self.rect = self.image.get_rect()
            # Set the initial position of the agent
            self.rect.topleft = initial_position  

        def update_position(self, new_position:tuple[int,int]):
            # HACK: this may not be the best way to do this
            self.rect.topleft = new_position  

    def __init__(self, tk:TurningKernel=TurningKernel(),# this is equivelant to a flat kernel 
                 pos:tuple[int,int] = (SCREENSIZE[0]//2,SCREENSIZE[1]//2)):
        # init parameters 
        self.saturation = 0
        self.pos = pos
        # PATH TO DEFAULT ANT SPRITE
        self.img = pg.image.load(PWD + "/imgs/ant.png")
        self.sprite = self._Sprite(image=self.img, initial_position = pos)

    def move(self,dxpos,dypos):
        self.pos = (self.pos[0]+dxpos, self.pos[1]+dypos)
        self.sprite.update_position(self.pos) 

if __name__ == "__main__":
    # main program loop

    pg.init()
    board = pg.display.set_caption("simulation") 
    screen = pg.display.set_mode(SCREENSIZE)
    clock  = pg.time.Clock()

    # TODO: Add wide turning kernel from paper
    wide_tk = TurningKernel()

    # TODO: Add narrow turning kernel from paper
    narrow_tk = TurningKernel()
    flat_tk = TurningKernel()

    # group to maintain all agents
    agent_sprites = pg.sprite.Group()
    all_agents = []
    
    pheromone_trails = pg.sprite.Group()


    for agent_id in range(0,args.agents):
        new_agent = Agent(tk=flat_tk)
        all_agents.append(new_agent)
        agent_sprites.add(new_agent.sprite)

    if args.time_step and args.time:
        epoch = np.arange(start=0.0, stop=args.time, step=args.time_step)
    else:
        epoch = np.arange(start=0.0, stop=1500, step=1.0)

    for ctime in epoch:
        # NOTE: this will serve as our update loop. 
        # Every cycle of our model is updated from within this loop
        
        # check the length of agents in our list, if less then max try to add one
        if len(agent_sprites) < args.agents:
            new_agent = Agent(tk=flat_tk)
            all_agents.append(new_agent)
            agent_sprites.add(new_agent.sprite)
        
        # check for ants outside of the display, remove if true
        for i in agent_sprites:
            if not pg.contains(i):
                pg.kill(i)
                
        
        # TODO: Find a way to remove the agents from the all agent list 
        
        # leave a pheromone behind/ at the current location, if already pheromone there, 
        # update its strength
        
        # update the positions of each agent
        
        # 
        
    
    
        #pheromone_trail()
