import numpy as np
import argparse as ap
import sys
import pygame
from os import getcwd

# NOTE: handle argparsing
parser = ap.ArgumentParser(description="A script to generate an agent based model simulating paths generated by ants and their pheromone trails")

parser.add_argument("--agents", type=int, help="Max number of concurrent agents in the model")
parser.add_argument("--kernel", type=str, help="Selected turning kernel")
parser.add_argument("--fidelity", type=int, help="Select which fidelity case to model") 
#TODO: this^ may need to be a boolean
parser.add_argument("--max-time", type=int, help="Max simulation time our model will run")
parser.add_argument("--time-step", type=float, help="Time resolution of our model")

args = parser.parse_args()


# NOTE: this is serving as a preamble of init classes / importing parameters

PWD = getcwd()
MAX_FIDELITY:float = 100
MIN_FIDELITY:float = 0
MAX_SATURATION:int = 20
tao = 20

board = np.zeros((255,255))


DIRECTIONS= [[315, 0, 45],[270, -1, 90],[225, 180,135]]


class TurningKernel():
    # making a class for turning kernels to act as a template we can alter later
    # TODO:look at a continously defined turning kernel
    def __init__(self, values:list[list[float]]=[[.1,.3,.1],[.1,0,.1],[.1,.1,.1]])->None:
        # loading weights
        self.turningKernel = np.array(values)
        
    def calc(self,direction:int):
        #TODO: apply rotation on matrix
        num90s = direction//90
        tmp = np.rot90(self.turningKernel.copy(),k=num90s)
        if direction - num90s //45:
            tmp = rot45(tmp)
        return tmp

class Agent():
    def __init__(self,):
        self.saturation = 0
        self.x = 127
        self.y = 127
        self.direction:int =  int(np.random.random()*8)*45# in degrees
        self.ontrail = False
        self.tk= TurningKernel()

    def get_position(self):
        return (self.x, self.y)

    def explore(self):
        matrix = self.tk.calc(direction=self.direction)
        outcome = roll(matrix)
        self.x += outcome//3 +1
        self.y += outcome%3 - 1
        self.direction = DIRECTIONS[outcome%3][outcome//3]

    def update(self, pc):
        
        # using current position, check what is next it, 
        mat = self.get_adj(pc)
        if not mat.shape == (3,3):
            
            pad_width = ((0, max(0, 3 - mat.shape[0])),
                 (0, max(0, 3- mat.shape[1])))
            np.pad(mat, pad_width=pad_width, mode="constant")
        # case where there is no pheromone adj
        if not np.sum(mat) > 0:
            self.explore()
            return None
        
        if mat[1][1] > 0:
            self.ontrail = True
            self.saturation +=1
        else:
            self.ontrail = False
            if self.saturation == 0:
                pass
            else:
                self.saturation -=1
        # staying at the same position is not an option
        mat[1][1] = 0

        fidelity = saturation_to_fidelity(self.saturation)

        # find out if we stay on trail or not        
        if flip(fidelity / MAX_FIDELITY):
            # Apply weight of pheromone concentrations onto turning kernel 
            weighted_matrix = mat * self.tk.calc(self.direction)
            # Normalize Matrix
            normalized_matrix = weighted_matrix/weighted_matrix.sum()
            outcome = roll(normalized_matrix)
            self.x += outcome//3 +1
            self.y += outcome%3 - 1
            self.direction = DIRECTIONS[outcome%3][outcome//3]
        else:
            self.explore()
            return None

    def get_adj(self,pheromone): 
        adj_tiles = pheromone[self.x-1:self.x+2,self.y-1:self.y+2]
        return adj_tiles

    def reset(self):
        self.saturation = 0
        self.x = 127
        self.y = 127
        self.direction:int =  int(np.random.random()*8)*45# in degrees
        self.ontrail = False


def rot45(matrix, direction="right"):
    if matrix.shape[0] != matrix.shape[1]:
        raise ValueError("Input matrix must be square (n x n)")
    n = matrix.shape[0]
    shifted_matrix = np.copy(matrix)
    if direction == "right":
        # Shift the top row to the right
        shifted_matrix[0, 1:] = matrix[0, :-1]
        # Shift the right column down
        shifted_matrix[1:, -1] = matrix[:-1, -1]
        # Shift the bottom row to the left
        shifted_matrix[-1, :-1] = matrix[-1, 1:]
        # Shift the left column up
        shifted_matrix[:-1, 0] = matrix[1:, 0]
    elif direction == "left":
        # Shift the top row to the left
        shifted_matrix[0, :-1] = matrix[0, 1:]
        # Shift the left column down
        shifted_matrix[1:, 0] = matrix[:-1, 0]
        # Shift the bottom row to the right
        shifted_matrix[-1, 1:] = matrix[-1, :-1]
        # Shift the right column up
        shifted_matrix[:-1, -1] = matrix[1:, -1]
    else:
        raise ValueError("Direction must be 'left' or 'right'")

    return shifted_matrix


def flip(p_true:float)->bool:
    if p_true > 1 or p_true < 0:
        raise ValueError("probability true must be in range [0,1]")
    return np.random.random()<p_true

def roll(nmatrix)->int:
    ''' 
    0 , 1 , 2
    3 , 4 , 5
    6 , 7 , 8 
    '''
    flat = nmatrix.ravel()
    flat = np.nan_to_num(flat)
    if flat.sum() == 0: flat[1] = 1
    outcome = int(np.random.choice(range(0,9),1,p=flat))
    return outcome

def saturation_to_fidelity( sat:int )->float:
    # NOTE: this method maps the saturation value to fidelity
    
    # Calculate the percentage of input value within the input range
    input_percentage = sat / MAX_SATURATION
    
    # Map the input percentage to the output range
    mapped_value = MIN_FIDELITY + (input_percentage * (MAX_FIDELITY - MIN_FIDELITY))
    
    return mapped_value


class Sim_Window():
    def __init__(self, wSize=(400, 400), gridSize:int=100, ):

        # Initialize Pygame
        pygame.init()
        # Constants
        self.WINDOW_SIZE = wSize
        self.GRID_SIZE = gridSize  # Number of squares in each row and column
        self.SQUARE_SIZE =self.WINDOW_SIZE[0] // self.GRID_SIZE
        
        # Colors
        self.WHITE = (255, 255, 255)
        self.BLACK = (0, 0, 0)
        self.screen = pygame.display.set_mode(self.WINDOW_SIZE)
        pygame.display.set_caption(f"Agent Model (n={args.agents})") 
        # Main loop
        self.running = True

    def update(self, pheromone):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
     
        # Clear the screen
        self.screen.fill(self.BLACK)
        
        # Draw the grid of squares based on the data
        for row in range(self.GRID_SIZE):
            for col in range(self.GRID_SIZE):
                data_value = pheromone[row][col]
                color = (data_value, 0, 0, data_value)
                pygame.draw.rect(self.screen, color, (col * self.SQUARE_SIZE, row * self.SQUARE_SIZE, self.SQUARE_SIZE, self.SQUARE_SIZE))
         
        # Update the display
        pygame.display.flip()
    
    def close(self):
        # Quit Pygame
        pygame.quit()
        sys.exit()

all_agents = np.array([Agent() for i in range(args.agents) ])
#all pheromones exist on their own board
pheromone_concentration = board.copy()

if __name__ == "__main__":
    # main program loop
    sim = Sim_Window(wSize=np.multiply(board.shape,4),
                     gridSize=len(board))

    # TODO: Add wide turning kernel from paper
    wide_tk = TurningKernel()

    # TODO: Add narrow turning kernel from paper
    narrow_tk = TurningKernel(
            values=[[.20,.20,.20],
                    [.15,0,.15],
                    [.05,0,.05]])
    flat_tk = TurningKernel()
    
    #TODO: add arg time into this statment
    epoch = np.arange(start=0.0, stop=1500, step=1.0) 

    #NOTE: this will serve as our update loop. 
    for ctime in epoch:
        # Every cycle of our model is updated from within this loop
        
        # update all ants
        xtmp = [] 
        ytmp = []
        for ant in all_agents:
            _x,_y = ant.get_position()
            if _x < 0 or _x>len(board)-1 or _y <0 or _y > len(board)-1:
                ant.reset()
                _x,_y = ant.get_position()
            xtmp.append(_x) 
            ytmp.append(_y)
            ant.update(pheromone_concentration)
        #print(f"xtmp:{xtmp}\nytmp:{ytmp}") 
        #NOTE: update pheromone trails
        for _x,_y in zip(xtmp, ytmp):
            pheromone_concentration[_x][_y] = tao
        # pheromone_concentration[xtmp][ytmp] = tao
        #NOTE: decrement all pheromone trails
        pheromone_concentration  -= 1
        #NOTE: prevent any negative values
        pheromone_concentration = np.maximum(pheromone_concentration,0)
        sim.update(np.multiply(pheromone_concentration, 255//tao))
    
    sim.close() 





